////////////////////////////////////////////////////////////////////////
// Module:				Blitzprog.Collection.Map
// Author:				Eduard Urbach
// Description:			Key/Value maps
////////////////////////////////////////////////////////////////////////

#ifndef BLITZPROG_COLLECTION_MAP_HPP_
#define BLITZPROG_COLLECTION_MAP_HPP_

////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////

//Modules
#include <Blitzprog/header.hpp>
#include <Blitzprog/Collection/Interface.hpp>

//Standard C++ Library
#include <map>

////////////////////////////////////////////////////////////////////////
// Constants
////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////
// Classes
////////////////////////////////////////////////////////////////////////

//Map
template <typename keyT, typename valueT>
class TMap: public std::map<keyT, valueT, less<keyT>, allocator<pair<const keyT, valueT> > >
{
	public:
		
		////////////////////////////////////////////////////////////////////////
		// Constructors and destructors
		////////////////////////////////////////////////////////////////////////
		
		//Constructor
		TMap()
		{
			//Debug info
			EngineLogNew("Map");
		}
		
		//Destructor
		~TMap()
		{
			//Debug info
			EngineLogDelete("Map");
		}
		
		////////////////////////////////////////////////////////////////////////
		// Operators
		////////////////////////////////////////////////////////////////////////
		
		
		
		////////////////////////////////////////////////////////////////////////
		// Casts
		////////////////////////////////////////////////////////////////////////
		
		
		
		////////////////////////////////////////////////////////////////////////
		// Methods
		////////////////////////////////////////////////////////////////////////
		
		
		
		////////////////////////////////////////////////////////////////////////
		// Inline methods
		////////////////////////////////////////////////////////////////////////
		
		//Add
		inline void Add(keyT key, valueT value)		//NOTE: Maybe references are possible, too.
		{
			//Debug info
			//EngineLogDetailed("Adding key/value to Map: " << key << "/" << value);
			
			//TODO: Check the performance (compare with map[key] = value)
			this->insert(make_pair(key, value));
		}
		
		//Find
		inline valueT &ValueForKey(keyT key)
		{
			return (*this)[key];
		}
		
		//Remove
		inline void Remove(keyT key)
		{
			this->erase(key);
		}
		
		//GetSize
		inline size_t GetSize()
		{
			return this->size();
		}
		
		//ToCPPMap
		inline map<keyT, valueT> &ToCPPMap()
		{
			return *this;
		}
};

//Map
template <typename keyT, typename valueT>
class Map : public SharedPtr<TMap<keyT, valueT> >
{
	private:
		typedef SharedPtr<TMap<keyT, valueT> > refMap;
		
	public:
		
		//Typedefs
		//typedef typename list<T>::iterator IteratorType;
		
		//Constructor
		Map() : refMap()
		{
			
		}
		
		//Constructor
		Map(TMap<keyT, valueT> *ptr) : refMap(ptr)
		{
			
		}
		
		//Operator []
		inline valueT &operator[](keyT key) const
		{
			//Debug info
			EngineLog5("Map search: " << key);
			
			return map<keyT, valueT>::operator[](key);
		}
};

////////////////////////////////////////////////////////////////////////
// Variables
////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////
// Inline functions
////////////////////////////////////////////////////////////////////////

//Operator == (Map)
template <typename keyT, typename valueT>
inline bool operator==(Map<keyT, valueT> &thisMap, Map<keyT, valueT> nMap)
{
	return map<keyT, valueT>(thisMap) == nMap;
}

//Operator == (std::map &)
template <typename keyT, typename valueT>
inline bool operator==(Map<keyT, valueT> &thisMap, map<keyT, valueT> &nMap)
{
	return thisMap == nMap;
}

#endif /*BLITZPROG_COLLECTION_MAP_HPP_*/
